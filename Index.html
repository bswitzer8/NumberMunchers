<!DOCTYPE html>
<html>
	<head>
        <meta charset="UTF-8" />
        <title>Number Munchers Game</title>
        <link rel="stylesheet" type="text/css" href="style.css"></link>
        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Press+Start+2P"></link>
        <script src="scripts/phaser.js"></script>
        <script src="scripts/firebase.js"></script>
        <script src="scripts/munchers.js"></script>

        <script type="text/javascript">
            munchers.grid.generateMultiple();
            munchers.grid.fill();
            var grid = munchers.grid.grid();
          
            var multipleOf = munchers.grid.number();

            var troggleRate = 2.5, troggleRateCount = 0; // every 5 seconds at first

            var muncher, troggle = [];
            var gridText = [];
            var score = 0, lives = 3, level = 1;
            var scoreText, scoreString, liveText, 
            liveString, levelString, levelText, multipleString, multipleText;


            // phaser stuff will be here
            window.onload = function() {

                // I want to play a game. </saw>
                var game = new Phaser.Game(800, 500, Phaser.AUTO, 'phaser-canvas', { preload: preload, create: create, update: update });

                function preload () {                
                    game.load.image("muncher", "assets/muncher.svg");
                    game.load.image("troggle", "assets/troggle.svg");
                    
                    game.stage.backgroundColor = "#000"

                    game.time.events.loop(Phaser.Timer.SECOND * 2, spawn, this);
                }
                function create () {

                    // sprites
                    muncher = game.add.sprite( 0, 0, "muncher");
                    muncher.gridX = 2;
                    muncher.gridY = 2;
                    placeOnGridAt(muncher, muncher.gridX, muncher.gridY);

                    muncher.scale.setTo(0.5, 0.5); // set scale, go!
                    

                    for(var x = 0; x < grid.length; ++x)
                    {
                        gridText[x] = [];
                        for(var y = 0; y < grid[x].length; ++y)
                        {
                            if(typeof grid[x][y] === "object")
                            {
                                gridText[x].push("");
                            }
                            else {
                            gridText[x].push(game.add.text(50 +(x * 100), 50 + (y * 80), grid[x][y], { font: "50px Times New Roman", fill: "#888888"  }))
                            
                            gridText[x][y].setVisable = true;
                            }
                        }

                    }
                   

                    // Text
                    scoreString = "Score: ";
                    scoreText = game.add.text(10, game.world.height - 40, scoreString + score, { font: "30px 'Press Start 2P'", fill: "rgb(46, 219, 46)"});
                    scoreText.setVisable = true;

                    liveString = "Lives: ";
                    liveText = game.add.text(game.world.centerX + 100, game.world.height - 40, liveString + lives, { font: "30px 'Press Start 2P'", fill: "rgb(46, 219, 46)"});
                    liveText.setVisable = true;

                    levelString = "Level: "
                    levelText = game.add.text(10, 10, levelString + "1", { font: "30px 'Press Start 2P'", fill: "rgb(46, 219, 46)"  });
                    levelText.setVisable = true;

                    multipleString = "Multiples of ";
                    multipleText = game.add.text(game.world.centerX - 70, 10, multipleString + multipleOf,  { font: "30px 'Press Start 2P'", fill: "rgb(46, 219, 46)"  });

                }

                function update() {
                    
                    game.input.keyboard.onUpCallback = function(e)
                    {    
                        if(game.paused) return; // paused game, go no further.


                        var yy = muncher.gridY;
                        var xx = muncher.gridX;

                        // hacky: bringing back the text back from the abyss.
                        gridText[xx][yy].x -= 1000;
                               
                         
                        if(e.key === "ArrowUp"){ 
                            placeOnGridAt(muncher, xx, --yy);
                        }
                        else if(e.key === "ArrowDown"){
                            placeOnGridAt(muncher, xx, ++yy);
                        }                        
                        else if(e.key === "ArrowLeft"){
                            placeOnGridAt(muncher, --xx, yy);
                        }
                        else if(e.key === "ArrowRight"){
                            placeOnGridAt(muncher, ++xx, yy);
                        }
                        if(e.key === " ") // space!
                        {
                            if(gridText[xx][yy].text != "" && grid[xx][yy] % multipleOf === 0)
                            {   
                               
                                score += 20 + ((level - 1) * 10); // scale that score with the level.
                                scoreText.text = scoreString + score; 
                            
                                gridText[xx][yy].text = "";    
                               
                                munchers.grid.blank(xx, yy);
                                if(munchers.grid.winCheck())
                                {
                                    game.paused = true;
                                    levelUp();
                                    return;
                                }
                            }
                            else
                            {
                                --lives;
                                liveText.text = liveString + lives; 
                                gridText[xx][yy].text = ""; 
                                munchers.grid.blank(xx, yy);
                                if(lives == 0)
                                {
                                    game.paused = true;
                                    gameOver();
                                    return;
                                }

                            }

                            munchers.grid.debug();
                        }
                    
                        // hacky hiding of the text the muncher is on. 
                        gridText[muncher.gridX][muncher.gridY].x += 1000;  
                    }

                  
                }

                function spawn()
                {
                    
                    moveTroggles(troggle);

                    troggleRateCount += .5;
                    console.log(troggle);
                    if(troggleRateCount >= troggleRate)
                    {
                        console.log("TROGGLE SPAWNED"); // spawn a troggle.
                        troggle.push(game.add.sprite(0, 0, "troggle"));
                        var pos = troggle.length - 1;
                        troggle[pos].scale.setTo(0.5, 0.5);
                        var coord = munchers.grid.generateMonster();
                        troggle[pos].gridX = coord[0];
                        troggle[pos].gridY = coord[1];
                        gridText[troggle[pos].gridX][troggle[pos].gridY].x += 1000
                        placeOnGridAt(troggle[pos], troggle[pos].gridX, troggle[pos].gridY);
                        troggleRateCount = 0;
                    }
                }

                function levelUp(){

                    ++level;                   
                    if(score % 5000 == 0 && lives < 3) lives += 1;
                    if(troggleRate > 2.5) troggleRate -= .5;       // more frequent troggles 

                    // new game stuff.
                    munchers.grid.generateMultiple();
                    munchers.grid.fill();

                    grid = munchers.grid.grid();
          
                    multipleOf = munchers.grid.number();

                    levelText.text = levelString + level;
                    multipleText.text = multipleString + multipleOf;
                    liveText.text = liveString + lives;

                    for(var x = 0; x < grid.length; ++x)
                    {
                        for(var y = 0; y < grid[x].length; ++y)
                        {
                            if(typeof grid[x][y] === "object")
                            {
                                gridText[x][y] = "";
                            }
                            else {
                                gridText[x][y].text = grid[x][y];
                                
                                gridText[x][y].setVisable = true;
                            }
                        }
                    }

                    muncher.gridX = 2;
                    muncher.gridY = 2;
                    placeOnGridAt(muncher, muncher.gridX, muncher.gridY);


                    game.paused = false;
                }

                function moveTroggles(troggles) {
                    ///       0
                    ///     1   2     
                    ///       3

                    for(var i = 0; i < troggles.length; ++i)
                    {
                        var choice = parseInt(Math.random() * 4);
                       
                        gridText[troggles[i].gridX][troggles[i].gridY].x -= 1000; // vanish it
                        
                        
                        if(choice === 0 && troggles[i].gridY > 0)               // 0 up
                           --troggles[i].gridY;
                        else if(choice === 1 && troggles[i].gridX > 0)       // 1 right
                           --troggles[i].gridX;
                        else if(choice === 2 && troggles[i].gridX < 5)      // 2  left
                           ++troggles[i].gridX;
                        else if(choice == 3 && troggles[i].gridY < 4)      // 3 down
                           ++troggles[i].gridY;
                        else                                    // kill the troggle.
                        {   
                            troggles[i].destroy();
                            troggles.splice(i, 1);
                            return; // go no further
                        }

                        gridText[troggles[i].gridX][troggles[i].gridY].x += 1000;
                        placeOnGridAt(troggles[i], troggles[i].gridX, troggles[i].gridY);
                    }


                }

                function placeOnGridAt(item, x, y)
                {
                  
                    if(x < 6 && x >= 0)
                    {
                        item.x = (x * 100) + 50;
                        item.gridX = x;
                    } 
        
                    if(y < 5 && y >= 0)
                    {
                        item.y = (y * 80) + 50;
                        item.gridY = y;
                    }
                       
                }

                function gameOver() {
                    // Display End game overlay

                    // Submit to the leader board

                    // prompt to play a game?
                }


                // Initiate authentication features
                munchers.fire.setAuth();
                // Load Phaser.io Game
                munchers.phaser.newGame();

            };

   		</script>
	</head>
    <body>
        <nav>
            <h1>Return of the Number Munchers</h1>
            <ul>
                <li><a id="links__login"        href="#" onclick="munchers.fire.login()"    >Log In</a></li>
                <li><a id="links__logout"       href="#" onclick="munchers.fire.logout()"   ></a></li>
                <li><a id="links__game"         href="#" onclick="munchers.phaser.newGame()">New Game</a></li>
                <li><a id="links__leader-board" href="leader-board.html"                    >View Leader Board</a></li>
            </ul>
        </nav>

        <main id="phaser-canvas"></main>

    </body>
</html>